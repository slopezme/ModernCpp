//###########
//# Derived Class Destruction
//###########

/*
- A child object is stored in memory as a parent object followed by the child part
    Shape *c = new Circle;          // Create a Circle object in allocated memory
    ...                              // Use the object
    delete c;                        // Release the memory

    - Which destructor(s) are called?
        - The destructor of the parent class is called first
        - The destructor of the child class is called next

*/

#include <iostream>
#include <vector>

using namespace std;

class Shape {
    public:
        virtual void draw() const { cout << "Drawing a generic shape" << endl; }
        ~Shape() { cout << "Goodbye from Shape Object" << endl; }
};

class Circle : public Shape {
    public:
        void draw() const override { cout << "Drawing a circle" << endl; }
        ~Circle() { cout << "Goodbye from Circle Object" << endl; }
};

void example1() {
    vector<Shape*> shapes;                  // Vector of pointers to Shape objects

    shapes.push_back(new Circle());         // Store a Circle in vector

    for (auto s : shapes)
        s->draw();

    for (auto s : shapes)                   // Release memory
        delete s;
}

//###########
//# Virtual Destructor
//###########

/*
If the destructor is not virtual, static binding will be used
    Shape *c = new Circle;          // Create a Circle object in allocated memory
    ...
    delete c;                        // Release the memory

We need to use dynamic binding 
- the destructor must be virtual

    Shape *c = new Circle;          // Create a Circle object in allocated memory
    ...
    delete c;                        // Calls ~Circle() followed by ~Shape()

*/

//###########
//# Synthesized Destructor
//###########

/*
- if we do not define a destructor, the compiler will synthesize one for us
- The default destructor  generated by the compiler is NOT virtual
- If we are going through a pointer to base, this means that the derived part of the object is not destroyed
    - memory leaks
    - Resource leaks
    - undefined behavior

*/

//###########
//# Virtual Destructor
//###########

/*
We can prevent this by implementing a destructor and making it virtual

virtual ~Shape() {}         // Empty virtual destructor (all C++)
virtual ~Shape() = default;  // Empty virtual destructor (C++11)

We do not need to implement the other special member functions
In general, if a class has virtual functions, it should have a virtual destructor

 */

class Shape2 {
    public:
        virtual void draw() const { cout << "Drawing a generic shape" << endl; }
        virtual ~Shape2() { cout << "Goodbye from Shape Object" << endl; }
};

class Circle2 : public Shape2 {
    public:
        void draw() const override { cout << "Drawing a circle" << endl; }
        ~Circle2() { cout << "Goodbye from Circle Object" << endl; }
};

void example2() {
    vector<Shape2*> shapes;                  // Vector of pointers to Shape objects

    shapes.push_back(new Circle2());         // Store a Circle in vector

    for (auto s : shapes)
        s->draw();

    for (auto s : shapes)                   // Release memory
        delete s;
}


int main() {

    cout << "Derived Class Destruction" << endl << endl;
    example1();

    cout << endl << "Virtual Destructor" << endl << endl;
    example2();
}
